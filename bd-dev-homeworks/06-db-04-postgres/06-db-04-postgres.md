## Задача 1

Используя Docker, поднимите инстанс PostgreSQL (версию 13). Данные БД сохраните в volume.

Подключитесь к БД PostgreSQL, используя `psql`.

Воспользуйтесь командой `\?` для вывода подсказки по имеющимся в `psql` управляющим командам.

**Найдите и приведите** управляющие команды для:

- вывода списка БД,
- подключения к БД,
- вывода списка таблиц,
- вывода описания содержимого таблиц,
- выхода из psql.

## Ответ:  

- вывода списка БД - \l  
- подключения к БД - \c  
- вывода списка таблиц - \dt  
- вывода описания содержимого таблиц - \d+  
- выхода из psql. - \q

---  

## Задача 2

Используя `psql`, создайте БД `test_database`.

Изучите [бэкап БД](https://github.com/netology-code/virt-homeworks/tree/virt-11/06-db-04-postgresql/test_data).

Восстановите бэкап БД в `test_database`.

Перейдите в управляющую консоль `psql` внутри контейнера.

Подключитесь к восстановленной БД и проведите операцию ANALYZE для сбора статистики по таблице.

Используя таблицу [pg_stats](https://postgrespro.ru/docs/postgresql/12/view-pg-stats), найдите столбец таблицы `orders` 
с наибольшим средним значением размера элементов в байтах.

**Приведите в ответе** команду, которую вы использовали для вычисления, и полученный результат.  

## Ответ:  

![1](https://github.com/pendolf1984/netology/assets/70535199/077941d3-9fc3-4c04-a1f1-d46be83c37d5)  

Наибольшее среднее значение у столбца *title*  

---  

## Задача 3

Архитектор и администратор БД выяснили, что ваша таблица orders разрослась до невиданных размеров и
поиск по ней занимает долгое время. Вам как успешному выпускнику курсов DevOps в Нетологии предложили
провести разбиение таблицы на 2: шардировать на orders_1 - price>499 и orders_2 - price<=499.

Предложите SQL-транзакцию для проведения этой операции.

Можно ли было изначально исключить ручное разбиение при проектировании таблицы orders?  

## Ответ:  

```
BEGIN;
CREATE TABLE orders_new(id SERIAL, title VARCHAR(80) NOT NULL, price integer DEFAULT 0) PARTITION BY RANGE (price);
CREATE TABLE orders_price_gt_499 PARTITION OF orders_new FOR VALUES FROM (500) TO (2147483647);
CREATE TABLE orders_price_lte_499 PARTITION OF orders_new FOR VALUES FROM (0) TO (500);
INSERT INTO orders_new SELECT * FROM orders;
DROP TABLE orders;
ALTER TABLE orders_new RENAME TO orders;
COMMIT;
```

Исключить ручное разбиение можно: 
- если изначально известное распределение по какому-то из полей
- Если мы заранее известно, что кол-во записей будет равномерно распредлено по какому-то полю, то шардировать можно при проектировании.

---  

## Задача 4

Используя утилиту `pg_dump`, создайте бекап БД `test_database`.

Как бы вы доработали бэкап-файл, чтобы добавить уникальность значения столбца `title` для таблиц `test_database`?  

## Ответ:  

```pg_dump -U postgres test_database > /var/lib/postgresql/backup/my_dump.sql```  

Как вариант - можно добавить UNIQUE или TIMESTAMP при объявления полей таблицы.

